{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE OverloadedStrings #-}

module Keccak256Spec (spec) where

import Crypto.Hash.Keccak256Native (keccak256)
import Data.ByteString.Base16 qualified as Base16
import Data.ByteString.Base64 qualified as Base64
import Data.Default (def)
import Data.Text (Text)
import Data.Text qualified as Text
import Data.Text.Encoding qualified as Text
import Data.Vector qualified as V
import Pact.Types.Exp (Literal(..))
import Pact.Types.Runtime (Term(..))
import Test.Hspec
import Control.Monad (forM_)

data Reference = Reference
  { input :: Text
  , output :: Text
  }

-- | Test vectors taken from https://keccak.team/archives.html.
--   "Known-answer and Monte Carlo test results, as of round 3 of the SHA-3 competition":
--   https://keccak.team/obsolete/KeccakKAT-3.zip
references :: [Reference]
references =
  [ Reference
      { input = ""
      , output = "C5D2460186F7233C927E7DB2DCC703C0E500B653CA82273B7BFAD8045D85A470"
      }
  , Reference
      { input = "20FF454369A5D05B81A78F3DB05819FEA9B08C2384F75CB0AB6AA115DD690DA3131874A1CA8F708AD1519EA952C1E249CB540D196392C79E87755424FEE7C890808C562722359EEA52E8A12FBBB969DD7961D2BA52037493755A5FA04F0D50A1AA26C9B44148C0D3B94D1C4A59A31ACA15AE8BD44ACB7833D8E91C4B86FA3135A423387B8151B4133ED23F6D7187B50EC2204AD901AD74D396E44274E0ECAFAAE17B3B9085E22260B35CA53B15CC52ABBA758AF6798FBD04ECEECED648F3AF4FDB3DED7557A9A5CFB7382612A8A8F3F45947D1A29CE29072928EC193CA25D51071BD5E1984ECF402F306EA762F0F25282F5296D997658BE3F983696FFA6D095C6369B4DAF79E9A5D3136229128F8EB63C12B9E9FA78AFF7A3E9E19A62022493CD136DEFBB5BB7BA1B938F367FD2F63EB5CA76C0B0FF21B9E36C3F07230CF3C3074E5DA587040A76975D7E39F4494ACE5486FCBF380AB7558C4FE89656335B82E4DB8659509EAB46A19613126E594042732DD4C411F41AA8CDEAC71C0FB40A94E6DA558C05E77B6182806F26D9AFDF3DA00C69419222C8186A6EFAD600B410E6CE2F2A797E49DC1F135319801FA6F396B06F975E2A190A023E474B618E7"
      , output = "0EC8D9D20DDF0A7B0251E941A7261B557507FF6287B504362A8F1734C5A91012"
      }
  , Reference
      { input = "4FBDC596508D24A2A0010E140980B809FB9C6D55EC75125891DD985D37665BD80F9BEB6A50207588ABF3CEEE8C77CD8A5AD48A9E0AA074ED388738362496D2FB2C87543BB3349EA64997CE3E7B424EA92D122F57DBB0855A803058437FE08AFB0C8B5E7179B9044BBF4D81A7163B3139E30888B536B0F957EFF99A7162F4CA5AA756A4A982DFADBF31EF255083C4B5C6C1B99A107D7D3AFFFDB89147C2CC4C9A2643F478E5E2D393AEA37B4C7CB4B5E97DADCF16B6B50AAE0F3B549ECE47746DB6CE6F67DD4406CD4E75595D5103D13F9DFA79372924D328F8DD1FCBEB5A8E2E8BF4C76DE08E3FC46AA021F989C49329C7ACAC5A688556D7BCBCB2A5D4BE69D3284E9C40EC4838EE8592120CE20A0B635ECADAA84FD5690509F54F77E35A417C584648BC9839B974E07BFAB0038E90295D0B13902530A830D1C2BDD53F1F9C9FAED43CA4EED0A8DD761BC7EDBDDA28A287C60CD42AF5F9C758E5C7250231C09A582563689AFC65E2B79A7A2B68200667752E9101746F03184E2399E4ED8835CB8E9AE90E296AF220AE234259FE0BD0BCC60F7A4A5FF3F70C5ED4DE9C8C519A10E962F673C82C5E9351786A8A3BFD570031857BD4C87F4FCA31ED4D50E14F2107DA02CB5058700B74EA241A8B41D78461658F1B2B90BFD84A4C2C9D6543861AB3C56451757DCFB9BA60333488DBDD02D601B41AAE317CA7474EB6E6DD"
      , output = "0EA33E2E34F572440640244C7F1F5F04697CE97139BDA72A6558D8663C02B388"
      }
  ]

spec :: Spec
spec = describe "keccak256" $ do
  it "produces correct results" $ do
    forM_ references $ \ref -> do
      hashInputAndCompareToOutput ref.input ref.output
      hashChunksAreEqual ref.input

hash :: Text -> Text
hash str = hashChunks [str]

hashChunks :: [Text] -> Text
hashChunks chunks = unwrap go
  where
    go :: Either String Text
    go = do
      vals <- traverse (Base16.decode . Text.encodeUtf8) chunks
      let lits = V.fromList $ flip map vals $ \lit ->
            TLiteral
              { _tLiteral = LString (Text.decodeUtf8 (Base64.encode lit))
              , _tInfo = def
              }
      rawHash <- Base64.decode
        $ Text.encodeUtf8
        $ keccak256 lits
      pure $ Text.decodeUtf8 $ Base16.encode rawHash

hashInputAndCompareToOutput :: Text -> Text -> IO ()
hashInputAndCompareToOutput i o = do
  Text.toLower (hash i) `shouldBe` Text.toLower o

hashChunksAreEqual :: Text -> IO ()
hashChunksAreEqual original = do
  let chunkSize = 10 -- random number i made up
  let chunks = Text.chunksOf chunkSize original
  Text.toLower (hash original) `shouldBe` Text.toLower (hashChunks chunks)

unwrap :: Either String a -> a
unwrap e = case e of
  Left err -> error err
  Right a -> a
